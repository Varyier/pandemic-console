<script>
  // all storable data
  var State = {
    Towns : 
    [
    // Blue - 'B'
      {name:'Atlanta',        color:'B', ways:[1,38], disB:0,disK:0,disR:0,disY:0, lab:true}, // 0
      {name:'Chicago',        color:'B', ways:[0,2,3,36,37], disB:0,disK:0,disR:0,disY:0, lab:false}, // 1
      {name:'SanFrancisco',   color:'B', ways:[1,31,34,36], disB:0,disK:0,disR:0,disY:0, lab:false}, // 2
      {name:'Monreal',        color:'B', ways:[1,4,5], disB:0,disK:0,disR:0,disY:0, lab:false}, // 3
      {name:'Washington',     color:'B', ways:[0,3,5,38], disB:0,disK:0,disR:0,disY:0, lab:false}, // 4
      {name:'NewYork',        color:'B', ways:[3,4,6,7], disB:0,disK:0,disR:0,disY:0, lab:false}, // 5
      {name:'London',         color:'B', ways:[5,7,8,9], disB:0,disK:0,disR:0,disY:0, lab:false}, // 6
      {name:'Madrid',         color:'B', ways:[5,6,9,12,43], disB:0,disK:0,disR:0,disY:0, lab:false}, // 7
      {name:'Essen',          color:'B', ways:[6,9,10,11], disB:0,disK:0,disR:0,disY:0, lab:false}, // 8
      {name:'Paris',          color:'B', ways:[6,7,8,11,12], disB:0,disK:0,disR:0,disY:0, lab:false}, // 9
      {name:'St.Petersburg',  color:'B', ways:[8,13,15], disB:0,disK:0,disR:0,disY:0, lab:false}, // 10
      {name:'Milan',          color:'B', ways:[8,9,13], disB:0,disK:0,disR:0,disY:0, lab:false}, // 11

      // Black - 'K'
      {name:'Algiers',  color:'K', ways:[7,9,13,14], disB:0,disK:0,disR:0,disY:0, lab:false}, // 12
      {name:'Istambul', color:'K', ways:[10,11,12,14,15,16], disB:0,disK:0,disR:0,disY:0, lab:false}, // 13
      {name:'Cairo',    color:'K', ways:[12,13,16,17], disB:0,disK:0,disR:0,disY:0, lab:false}, // 14
      {name:'Moscow',   color:'K', ways:[10,13,18], disB:0,disK:0,disR:0,disY:0, lab:false}, // 15
      {name:'Baghdad',  color:'K', ways:[13,14,17,18,19], disB:0,disK:0,disR:0,disY:0, lab:false}, // 16
      {name:'Riyadh',   color:'K', ways:[14,16,19], disB:0,disK:0,disR:0,disY:0, lab:false}, // 17
      {name:'Tehran',   color:'K', ways:[15,16,19,21], disB:0,disK:0,disR:0,disY:0, lab:false}, // 18
      {name:'Karachi',  color:'K', ways:[16,17,18,20,21], disB:0,disK:0,disR:0,disY:0, lab:false}, // 19
      {name:'Mumbai',   color:'K', ways:[19,21,22], disB:0,disK:0,disR:0,disY:0, lab:false}, // 20
      {name:'Delhi',    color:'K', ways:[18,19,20,22,23], disB:0,disK:0,disR:0,disY:0, lab:false}, // 21
      {name:'Chennai',  color:'K', ways:[20,21,23,24,25], disB:0,disK:0,disR:0,disY:0, lab:false}, // 22
      {name:'Kolkata',  color:'K', ways:[21,22,24,28], disB:0,disK:0,disR:0,disY:0, lab:false}, // 23

      // Red - 'R'
      {name:'Bangkok',       color:'R', ways:[22,23,25,28,29], disB:0,disK:0,disR:0,disY:0, lab:false}, // 24
      {name:'Jakarta',       color:'R', ways:[22,24,29,35], disB:0,disK:0,disR:0,disY:0, lab:false}, // 25
      {name:'Beijing',       color:'R', ways:[27,30], disB:0,disK:0,disR:0,disY:0, lab:false}, // 26
      {name:'Shanghai',      color:'R', ways:[26,28,30,31,33], disB:0,disK:0,disR:0,disY:0, lab:false}, // 27
      {name:'HongKong',      color:'R', ways:[23,24,27,29,33,34], disB:0,disK:0,disR:0,disY:0, lab:false}, // 28
      {name:'HoChiMinhCity', color:'R', ways:[24,25,28,34], disB:0,disK:0,disR:0,disY:0, lab:false}, // 29
      {name:'Seoul',         color:'R', ways:[26,27,31], disB:0,disK:0,disR:0,disY:0, lab:false}, // 30
      {name:'Tokyo',         color:'R', ways:[2,27,30,32], disB:0,disK:0,disR:0,disY:0, lab:false}, // 31
      {name:'Osaka',         color:'R', ways:[31,33], disB:0,disK:0,disR:0,disY:0, lab:false}, // 32
      {name:'Taipei',        color:'R', ways:[27,28,32,34], disB:0,disK:0,disR:0,disY:0, lab:false}, // 33
      {name:'Manila',        color:'R', ways:[2,28,29,33,35], disB:0,disK:0,disR:0,disY:0, lab:false}, // 34
      {name:'Sydney',        color:'R', ways:[25,34,36], disB:0,disK:0,disR:0,disY:0, lab:false}, // 35
      
      
      // Yellow - 'Y'
      {name:'LosAngeles',   color:'Y', ways:[1,2,34,37], disB:0,disK:0,disR:0,disY:0, lab:false}, // 36
      {name:'MexicoCity',   color:'Y', ways:[1,36,38,39,42], disB:0,disK:0,disR:0,disY:0, lab:false}, // 37
      {name:'Miami',        color:'Y', ways:[0,4,37,39], disB:0,disK:0,disR:0,disY:0, lab:false}, // 38
      {name:'Bogota',       color:'Y', ways:[37,38,42,43,46], disB:0,disK:0,disR:0,disY:0, lab:false}, // 39
      {name:'Lagos',        color:'Y', ways:[41,43,44], disB:0,disK:0,disR:0,disY:0, lab:false}, // 40
      {name:'Khartoum',     color:'Y', ways:[14,40,44,47], disB:0,disK:0,disR:0,disY:0, lab:false}, // 41
      {name:'Lima',         color:'Y', ways:[37,39,45], disB:0,disK:0,disR:0,disY:0, lab:false}, // 42
      {name:'SaoPaulo',     color:'Y', ways:[7,39,40,46], disB:0,disK:0,disR:0,disY:0, lab:false}, // 43
      {name:'Kinshasa',     color:'Y', ways:[40,41,47], disB:0,disK:0,disR:0,disY:0, lab:false}, // 44
      {name:'Santiago',     color:'Y', ways:[42], disB:0,disK:0,disR:0,disY:0, lab:false}, // 45
      {name:'BuenosAires',  color:'Y', ways:[39,43], disB:0,disK:0,disR:0,disY:0, lab:false}, // 46
      {name:'Johannesburg', color:'Y', ways:[41,44], disB:0,disK:0,disR:0,disY:0, lab:false} // 47
    ],
    
    Classes :
    [
      'Researcher',
      'Scientist',
      'Medic',
      //'Engeneer',
      'Quarantine Specialist'
    ],
    
    // define two players
    Players :
    [
      {name:'Player1', pclass:0, hand:[], acts:3, pos:0},
      {name:'Player2', pclass:1, hand:[], acts:3, pos:0}
    ],
    
    infect_deck : [],
    infect_drop : [],
    
    // -1 - teleport
    // -2 - free lab
    // -3 - silent night
    // -13 - !INFECT
    help_deck : [],
    help_drop : [],
    
    is_silent_night:false,
    dis_marker:2, // number of cards from infect deck, to use
    dis_markers: [2,2,2,3,3,4,4],
    outbreak_counter:0, // >=7 - lose
    cur_turn:0,
    cur_player:0,
    first_player:0,
    
    remedyB:false,
    remedyK:false,
    remedyR:false,
    remedyY:false,
    
    defeatedB:false,
    defeatedK:false,
    defeatedR:false,
    defeatedY:false,
    
    epidemy_count:6,
    epidemy_id:0,
    
    started:false,
    
    disCntB:0,
    disCntK:0,
    disCntR:0,
    disCntY:0,
    
    DIS_MAX:24,  // if more - game is lost
    OUTBR_MAX:7,  // if more - game is lost
    ACTS_MAX:4,
    CARDS_PER_TURN:2,
    CARDS_PER_PLAYER_START:4
  };

  // COMMANDS:
  // /help - displays help
  // /start - start new game
  // /hands - check all cards in players' hands
  // /where - check all players' position
  // /ways - show all road ways from the current position of the current player
  // /ways 'NAME' - show all road ways from a specified town
  // /heal - clean one (OR all, if can) disease element from the current position (if exist any)
  // /heal CLR - clean one (OR all, if can) disease element from the current position (if exist any)
  // /aleft - show available actions
  // /info - detailed info about the game state
  
  // /lab - builds a lab in the current town, spends card
  // /lab -E - (Engeneer Only) builds a lab in the current town, doesn't spend card
  
  // /fly 'NAME' - teleports current player to the specified town 'NAME', spends card 'NAME'
  // /warp 'SNAME' - teleports current player to the specified town 'SNAME', spends card of the current town
  // /warp -E 'NAME' 'SNAME' - (Engeneer Only) teleports current player if he or she stands in a city with Lab,
  //                           to the specified town 'NAME', spends card 'SNAME' (one time per turn)
  // /lwarp 'NAME' - warp to town
  
  // /drive 'NAME' - go to a town, that is next to current position
  
  // /cchange <'PLAYER_NAME'> - gives the card of the current town from another player to the current player or backward, must be in that town both
  // /cchange 'NAME' <'PLAYER_NAME'> - gives the card 'NAME' from the Researcher to the other player, one of which must be current player
  // if current player is trying to give the card, and there are more, than two players in that town - must specify the recipient
  
  // /remedy 'X' 'NAME1', 'NAME2' - invent the remedy from the specified disease 'X', using two cards 'NAME1', 'NAME2'
  // /turn - end the turn
  
  var req_st = {
    command:'',
    arg1:'',
    arg2:'',
    arg3:''
  };
  
  function parse_req(req) {
    req_st.command = '';
    if(req.indexOf('/') != 0) {
      alert('Wrong request. Type \'/help\' for more info.');
    } else {
      var pos_cmd_delim = req.indexOf(' ');
      if(pos_cmd_delim == -1) {
        // no args
        req_st.command = req.slice(1, req.length);
      } else {
        // with args, probably
        req_st.command = req.slice(1, pos_cmd_delim);
      }
      
      req_st.arg1 = '';
      req_st.arg2 = '';
      req_st.arg3 = '';
      
      if(pos_cmd_delim != -1) {
        var req_cut = req.slice(pos_cmd_delim+1, req.length);
        if(req_cut.length > 0) {        
          // at least 1 arg
          var pos_arg1_delim = req_cut.indexOf(' ');
          if(pos_arg1_delim != -1) {
            req_st.arg1 = req_cut.slice(0, pos_arg1_delim);
          } else {
            req_st.arg1 = req_cut.slice(0, req_cut.length);
          }
          
          if(pos_arg1_delim != -1) {
            var req_cut2 = req_cut.slice(pos_arg1_delim+1, req_cut.length);
            if(req_cut2.length > 0) {
              var pos_arg2_delim = req_cut2.indexOf(' ');
              if(pos_arg2_delim != -1) {
                req_st.arg2 = req_cut2.slice(0, pos_arg2_delim);
              } else {
                req_st.arg2 = req_cut2.slice(0, req_cut2.length);
              }
              
              if(pos_arg2_delim != -1) {
                var req_cut3 = req_cut2.slice(pos_arg2_delim+1, req_cut2.length);
                if(req_cut3.length > 0) {
                  var pos_arg3_delim = req_cut3.indexOf(' ');
                  if(pos_arg3_delim != -1) {
                    req_st.arg3 = req_cut3.slice(0, pos_arg3_delim);
                  } else {
                    req_st.arg3 = req_cut3.slice(0, req_cut3.length);
                  }
                  
                  //req_cut = req_cut.slice(pos_arg3_delim+1, req_cut.length);
                  
                }
              }
            }
          }
        }
      }

      // remove quotes
      if(req_st.arg1.indexOf('\'') == 0 && req_st.arg1.lastIndexOf('\'') == (req_st.arg1.length-1)) {
        req_st.arg1 = req_st.arg1.slice(1,req_st.arg1.length-1);
      }
      if(req_st.arg2.indexOf('\'') == 0 && req_st.arg2.lastIndexOf('\'') == (req_st.arg2.length-1)) {
        req_st.arg2 = req_st.arg2.slice(1,req_st.arg2.length-1);
      }
      if(req_st.arg3.indexOf('\'') == 0 && req_st.arg3.lastIndexOf('\'') == (req_st.arg3.length-1)) {
        req_st.arg3 = req_st.arg3.slice(1,req_st.arg3.length-1);
      }
    }
  }
  
  function getRndInteger(min, max) {
    return Math.floor(Math.random() * (max - min) ) + min;
  }
  
  function swapElems(arr, e1i, e2i) {
    var tmp = arr[e1i];
    arr[e1i] = arr[e2i];
    arr[e2i] = tmp;
  }
  
  function shuffleArr(arr) {
    var i=0;
    for(i=0; i<arr.length; i++) {
      var e1i = getRndInteger(0, arr.length);
      var e2i = getRndInteger(0, arr.length);
      swapElems(arr, e1i, e2i);
    }
  }  
  
  function getCardDispName(card_id) {
    if(card_id < 0) {
      if(card_id == -1) {
        return '!Teleport'
      } else if (card_id == -2) {
        return '!FreeLab';
      } else if (card_id == -3) {
        return '!SilentNight';
      } else if (card_id == -13) {
        return 'EPIDEMY!';
      }
      
      return '!!!Undefined';
    }
    return State.Towns[card_id].name;
  }
  
  function infectTown(t_id, color, already_prop) {
    // Qua Spec prevents propagation
    // not affect setup
    if(State.started) {
      var qua_spec_p_id = getPlayerIdByClassName('Quarantine Specialist');
      if(qua_spec_p_id >= 0) {
        var qua_spec_pos = State.Players[qua_spec_p_id].pos;
        if(qua_spec_pos == t_id) {
          log('Quarantine Specialist prevents infection in \'' + State.Towns[t_id].name + '\'.');
          return true;
        }
        var i=0;
        for(i=0; i<State.Towns[qua_spec_pos].ways.length; i++) {
          if(State.Towns[qua_spec_pos].ways[i] == t_id) {
            log('Quarantine Specialist prevents infection in \'' + State.Towns[t_id].name + '\'.');
            return true;
          }
        }
      }
    }
  
    // Medic prevents placing cubes of the disease with remedy, if stands in this town
    var medic_id = getPlayerIdByClassName('Medic');
    if(medic_id >= 0) {
      if(t_id == State.Players[medic_id].pos) {
        if(color == 'B' && State.remedyB) {
          log('Medic prevents infecting of \'' + State.Towns[t_id].name + '\' by Blue disease.');
          return true;
        } else if(color == 'K' && State.remedyK) {
          log('Medic prevents infecting of \'' + State.Towns[t_id].name + '\' by Black disease.');
          return true;
        } else if(color == 'R' && State.remedyR) {
          log('Medic prevents infecting of \'' + State.Towns[t_id].name + '\' by Red disease.');
          return true;
        } else if(color == 'Y' && State.remedyY) {
          log('Medic prevents infecting of \'' + State.Towns[t_id].name + '\' by Yellow disease.');
          return true;
        }
      }
    }
  
    function match(elem) {
      return elem == t_id;
    }
    
    if(!State.defeatedB && color == 'B') {
      if(State.Towns[t_id].disB >= 3) {
        State.Towns[t_id].disB = 3;
        if(already_prop.findIndex(match) < 0) {
          if(!outbrDisease(t_id, color, already_prop)) {
            return false;
          }
        }
      } else {
        State.Towns[t_id].disB++;
        State.disCntB++;
        if(State.disCntB > State.DIS_MAX) {
          Lose('Blue disease spreads too fast');
          return false;
        }
      }
    } else if (!State.defeatedK && color == 'K') {
      if(State.Towns[t_id].disK >= 3) {
        State.Towns[t_id].disK = 3;
        if(already_prop.findIndex(match) < 0) {
          if(!outbrDisease(t_id, color, already_prop)) {
            return false;
          }
        }
      } else {
        State.Towns[t_id].disK++;
        State.disCntK++;
        if(State.disCntK > State.DIS_MAX) {
          Lose('Black disease spreads too fast');
          return false;
        }
      }
    } else if (!State.defeatedR && color == 'R') {
      if(State.Towns[t_id].disR >= 3) {
        State.Towns[t_id].disR = 3;
        if(already_prop.findIndex(match) < 0) {
          if(!outbrDisease(t_id, color, already_prop)) {
            return false;
          }
        }
      } else {
        State.Towns[t_id].disR++;
        State.disCntR++;
        if(State.disCntR > State.DIS_MAX) {
          Lose('Red disease spreads too fast');
          return false;
        }
      }
    } else if (!State.defeatedY && color == 'Y') {
      if(State.Towns[t_id].disY >= 3) {
        State.Towns[t_id].disY = 3;
        if(already_prop.findIndex(match) < 0) {
          if(!outbrDisease(t_id, color, already_prop)) {
            return false;
          }
        }
      } else {
        State.Towns[t_id].disY++;
        State.disCntY++;
        if(State.disCntY > State.DIS_MAX) {
          Lose('Yellow disease spreads too fast');
          return false;
        }
      }
    }
    
    return true;
  }
  
  function outbrDisease(t_id, color, already_prop) {
    // Qua Spec prevents propagation
    // not affect setup (doesn't matter, though)
//    if(State.started) {
//      var qua_spec_p_id = getPlayerIdByClassName('Quarantine Specialist');
//      if(qua_spec_p_id >= 0) {
//        var qua_spec_pos = State.Players[qua_spec_p_id].pos;
//        if(qua_spec_pos == t_id) {
//          log('Quarantine Specialist prevents outbreak in \'' + State.Towns[t_id].name + '\'.');
//          return;
//        }
//        var i=0;
//        for(i=0; i<State.Towns[qua_spec_pos].ways.length; i++) {
//          if(State.Towns[qua_spec_pos].ways[i] == t_id) {
//            log('Quarantine Specialist prevents outbreak in \'' + State.Towns[t_id].name + '\'.');
//            return;
//          }
//        }
//      }
//    }
  
    log('Outbreak in \'' + State.Towns[t_id].name + '\'!');
    already_prop.push(t_id);
    // increment number of outbreaks
    State.outbreak_counter++;
    if(State.outbreak_counter > State.OUTBR_MAX) {
      Lose('too many outbreaks');
    } else {
      var i=0;
      for(i=0; i<State.Towns[t_id].ways.length; i++) {
        if(!infectTown(State.Towns[t_id].ways[i], color, already_prop)) {
          return false;
        }
      }
    }
    
    return true;
  }  
  
  function getInfection(t_id, color) {
    if(color == 'B') {
      return State.Towns[t_id].disB;
    } else if (color == 'K') {
      return State.Towns[t_id].disK;
    } else if (color == 'R') {
      return State.Towns[t_id].disR;
    } else if (color == 'Y') {
      return State.Towns[t_id].disY;
    }
    
    return -1;
  }
  
  function getInfectionStrFull(t_id) {
    str = 'City';
    str += ' \'';
    str += State.Towns[t_id].name;
    str += '\'';
    str += 'is infected by ';
    var bfirst = true;
    if(State.Towns[t_id].disB > 0) {
      str += '\'B\' - ';
      str += State.Towns[t_id].disB;
      bfirst = false;
    }
    if(State.Towns[t_id].disK > 0) {
      if(!bfirst) {
        str += ', '
      }
      str += '\'K\' - ';
      str += State.Towns[t_id].disK;
      bfirst = false;
    }
    if(State.Towns[t_id].disR > 0) {
      if(!bfirst) {
        str += ', '
      }
      str += '\'R\' - ';
      str += State.Towns[t_id].disR;
      bfirst = false;
    }
    if(State.Towns[t_id].disY > 0) {
      if(!bfirst) {
        str += ', '
      }
      str += '\'Y\' - ';
      str += State.Towns[t_id].disY;
      bfirst = false;
    }
    if(bfirst) {
      str += 'NOTHING';
    }
    
    str += ';'

    return str;
  }
  
  function getTownIdByName(name) {
    var i=0;
    for(i=0; i<State.Towns.length; i++) {
      if(State.Towns[i].name == name) {
        return i;
      }
    }
    
    return -1;
  }
  
  function isTownInWays(t_id, wt_id) {
    var i=0;
    for(i=0; i<State.Towns[wt_id].ways.length; i++) {
      if(State.Towns[wt_id].ways[i] == t_id) {
        return true;
      }
    }
    
    return false;
  }
  
  function getPlayerIdByClassName(cname) {
    function match_cid(cn) {
      return cn == cname;
    }
    
    var c_id = State.Classes.findIndex(match_cid);
    if(c_id < 0) {
      return -1;
    }
    
    function match(pl) {
      return pl.pclass == c_id;
    }
    
    return State.Players.findIndex(match);
  }
  
  function getPlayerIdByName(pname) {
    var i=0;
    for(i=0; i<State.Players.length; i++) {
      if(State.Players[i].name == pname) {
        return i;
      }
    }
    
    return -1;
  }
  
  function log(str) {
      o_val = document.getElementById('allOutput').value;
      document.getElementById('allOutput').innerHTML = o_val + '\n' + str;
  }
  
  function process() {
    var cmd = req_st.command;
    var arg1 = req_st.arg1;
    var arg2 = req_st.arg2;
    var arg3 = req_st.arg3;

    if(cmd == 'help') {
      Help();
    } else if(cmd == 'start') {
      Init();
    } else if(cmd == 'ways' && State.started) {
      Ways(arg1);
    } else if(cmd == 'where' && State.started) {
      Where();
    } else if(cmd == 'drive' && State.started) {
      Drive(arg1);
    } else if(cmd == 'fly' && State.started) {
      Fly(arg1);
    } else if(cmd == 'warp' && State.started) {
      Warp(arg1, arg2, arg3);
    } else if(cmd == 'turn' && State.started) {
      Turn();
    } else if(cmd == 'heal' && State.started) {
      Heal(arg1);
    } else if(cmd == 'remedy' && State.started) {
      Remedy(arg1, arg2, arg3);
    } else if(cmd == 'cchange' && State.started) {
      Cchange(arg1, arg2);
    } else if(cmd == 'info' && State.started) {
      Info();
    } else if(cmd == 'misc_clr') {
      document.getElementById('allOutput').innerHTML = "";
    } else if(cmd == 'misc_rules') {
      //log('This is the legendary \'Pandemic\' board game. Here you and your friends is a group of people, who tries to defeat '
      //    'four deadly diseases, that are trying to kill the humanity! You are travelling across the Earth to find the remedy for each disease.\n'
      //    '  The Earth is divided into several cities, that are connected with several roads. There are four diseases (Red, Yellow, Blue and Black), and four city kinds,'
      //    ' that are in the risk group of the corresponding disease. Color indicators are: \'R\' for Red, \'Y\' for yellow, \'B\' for blue, \'K\' for black. '
      //    ' So, when infection comes, cities is usually being infected by the disease of their own color.\n'
      //    '  The game cycle is structured as follows:\n'
      //    ' 1) Player performs his or her turn;\n'
      //    ' 2) Player draws two helper cards;\n'
      //    ' 3) Infection comes;\n'
      //    'This actions are looped until the end of the game.\n'
      //    '  There are two decks used in this game:\n'
      //    ' 1) Helper deck (or, originally, Player deck) - cards, that helps players to defeat the diseases with a little surprise...;'
      //    ' 2) Infection deck - cards, that identifying cities, that gets additional disease markers;'
      //    '  Any players can perform these actions:\n'
      //    ' 1) Move directly to the nearest city, typing \'/drive \'CITY_NAME\'\';'
      //    ' 2) Move to any city, using \'/fly\' and spend the card of that city;\n'
      //    ' 3) Move to any city by player\'s choice and spend the card of the city, the player is in at this time - command \'/warp \'DEST_CITY_NAME\'\';\n'
      //    ' 4) Move from a city with Lab to another city with Lab - command lwarp \'CITY_NAME\';\n'
      //    ' 5) Give the card of a city, current player stands in, to another player, who stands at the same city; - type \'/cchange <\'PLAYER_NAME\'>\','
      //    'player name is needed only in case you\'re trying to give the card to one of several players, stood in the current town;\n'
      //    ' 6) Build a Lab for warping and inventing remedies. Type \'Lab\' to spend card of the current city and build Lab there;'
      //    ' 7) Heal the disease in the current city. Type \'/heal\' to heal all disease you can in the current city of its own color. '
      //    'Type \'/heal COLOR_ID\' to heal the disease of another color.'
      //    ' 8) Invent the remedy from the disease. Type \'/remedy COLOR_ID CARD1_NAME CARD2_NAME\' to invent the remedy from the disease of color COLOR_ID '
      //    'using five city cards of that color, so you must have them (and extra cards, you specified). Scientist needs only four. '
      //    'CARDi_NAME - card names, that you DON\'T want to use in the recipe (usually, it\'s enough to determine all cards, you actually want to use, '
      //    'but if a Scientist has seven cards of one color, the third not used card will be chosen randomly - VERY RARE CASE).'
          
      //    '          You should do two common things:\n'
      //    '1) Heal the disease. Type \'/heal\', while you are in the city with the existing disease to heal, what you can heal of the color, that this city has.'
      //    'Type \'/heal \'COLOR_ID\'\''
          
      //    'See full rules, for example, here: https://images-cdn.zmangames.com/us-east-1/filer_public/25/12/251252dd-1338-4f78-b90d-afe073c72363/zm7101_pandemic_rules.pdf');
    } else if(!State.started) {
      log('Start the game first.');
    } else {
      alert('Invalid command ' + req_st.command);
    }
  }
  
  function mymain() {
    i_val = document.getElementById('mainInput').value;
    if(i_val.length > 0) {
      o_val = document.getElementById('allOutput').value;
      document.getElementById('allOutput').innerHTML = o_val + '\n' + '>> ' + i_val;
      document.getElementById('mainInput').value = '';
      
      parse_req(i_val);
      if(req_st.command.length > 0) {
        // load game state
        if(document.getElementById('ST').value != '') {
          State = JSON.parse(document.getElementById('ST').value);
        }
        // process one step (command)
        process();
        // store game state
        document.getElementById('ST').innerHTML = JSON.stringify(State);
      }
    }
  }
  
  // STUFF
  function drawCards(p_id) {
    if(State.help_deck.length <= 0) {
      Lose('help deck has drained');
      return false;
    } else {
      State.Players[p_id].hand.push(State.help_deck[State.help_deck.length-1]);
      State.help_deck.pop();
      return true;
    }
  }
  
  function Init() {
    State.started = false;

    var i=0;
  
    for(i=0; i<State.Towns.length; i++) {
      State.Towns[i].disB = 
      State.Towns[i].disK =
      State.Towns[i].disR = 
      State.Towns[i].disY = 0;
      // lab only in Atlanta
      State.Towns[i].lab = (i==0);
    }
    
    State.remedyB =
    State.remedyK =
    State.remedyR = 
    State.remedyY = false;
    
    State.defeatedB =
    State.defeatedK =
    State.defeatedR = 
    State.defeatedY = false;
    
    State.disCntB = 
    State.disCntK = 
    State.disCntR = 
    State.disCntY = 0;
    
    // -1 - teleport
    // -2 - free lab
    // -3 - silent night
    // -13 - !INFECT (must be 3)
    State.infect_deck = [];
    State.infect_drop = [];
    
    State.help_deck = [-1,-2,-3];
    State.help_drop = [];
    
    // add all City cards into both decks
    for(i=0; i<State.Towns.length; i++) {
      State.infect_deck.push(i);
      State.help_deck.push(i);
    }
    
    // shuffle both decks
    shuffleArr(State.help_deck);
    shuffleArr(State.infect_deck);
    
    // Init Players, assigning classes
    var classes_left = [];
    for(i=0; i<State.Classes.length; i++) {
      classes_left.push(i);
    }
    
    shuffleArr(classes_left);
    for(i=0; i<State.Players.length; i++) {
      State.Players[i].pclass = classes_left[i];
      State.Players[i].hand = [];
      var j=0;
      for(j=0; j<State.CARDS_PER_PLAYER_START; j++) {
        drawCards(i);
      }
      State.Players[i].acts = State.ACTS_MAX;
      State.Players[i].pos = 0; // Atlanta
    }
    
    // init Epidemies (always four for now)
    State.epidemy_count = 4;
    State.epidemy_id = 0;
    
    var epi_arrs = [];
    var epi_mod = State.help_deck.length % State.epidemy_count;
    var nTaken = 0;
    for(i=0;i<State.epidemy_count; i++) {
      var id = epi_arrs.length;
      epi_arrs.push([]);
      var size = (State.help_deck.length-epi_mod) / State.epidemy_count;
      if(i<epi_mod) {
        size++;
      }
      var j=0;
      for(j=0; j<size; j++) {
        epi_arrs[id].push(State.help_deck[nTaken++]);
      }
      epi_arrs[id].push(-13);
      shuffleArr(epi_arrs[id]);
    }
    State.help_deck = [];
    for(i=0; i<State.epidemy_count; i++) {
      var j=0;
      for(j=0; j<epi_arrs[i].length; j++) {
        State.help_deck.push(epi_arrs[i][j]);
      }
    }
    
    State.is_silent_night = false;
    State.dis_marker = 2;
    State.outbreak_counter = 0;
    State.cur_turn = 0;
    State.first_player = State.cur_player = getRndInteger(0, State.Players.length);
    
    log('New game started.');
    for(i=0; i<State.Players.length; i++) {
      var str = 'Player';
      str += ' \'';
      str += State.Players[i].name;
      str += '\'';
      
      str += ' is \''
      str += State.Classes[State.Players[i].pclass];
      str += '\','
      
      str += ' has: ';
      
      var j=0;
      for(j=0; j<State.Players[i].hand.length; j++) {
        str += ' \'';
        str += getCardDispName(State.Players[i].hand[j]);
        str += '\'';
        if(j<State.Players[i].hand.length-1) {
        str += ', ';
        }
      }
      
      str += ';';
      log(str);
    }
    
    var str = '';
    // initial infect
    // 3
    var infect = State.infect_deck[State.infect_deck.length-1];
    var arr = [];
    State.infect_deck.pop();
    State.infect_drop.push(infect);
    infectTown(infect, State.Towns[infect].color, arr);
    infectTown(infect, State.Towns[infect].color, arr);
    infectTown(infect, State.Towns[infect].color, arr);
    log(getInfectionStrFull(infect));
    
    infect = State.infect_deck[State.infect_deck.length-1];
    State.infect_deck.pop();
    State.infect_drop.push(infect);
    infectTown(infect, State.Towns[infect].color, arr);
    infectTown(infect, State.Towns[infect].color, arr);
    infectTown(infect, State.Towns[infect].color, arr);
    log(getInfectionStrFull(infect));
    
    infect = State.infect_deck[State.infect_deck.length-1];
    State.infect_deck.pop();
    State.infect_drop.push(infect);
    infectTown(infect, State.Towns[infect].color, arr);
    infectTown(infect, State.Towns[infect].color, arr);
    infectTown(infect, State.Towns[infect].color, arr);
    log(getInfectionStrFull(infect));
    
    // 2
    infect = State.infect_deck[State.infect_deck.length-1];
    State.infect_deck.pop();
    State.infect_drop.push(infect);
    infectTown(infect, State.Towns[infect].color, arr);
    infectTown(infect, State.Towns[infect].color, arr);
    log(getInfectionStrFull(infect));
    
    infect = State.infect_deck[State.infect_deck.length-1];
    State.infect_deck.pop();
    State.infect_drop.push(infect);
    infectTown(infect, State.Towns[infect].color, arr);
    infectTown(infect, State.Towns[infect].color, arr);
    log(getInfectionStrFull(infect));

    infect = State.infect_deck[State.infect_deck.length-1];
    State.infect_deck.pop();
    State.infect_drop.push(infect);
    infectTown(infect, State.Towns[infect].color, arr);
    infectTown(infect, State.Towns[infect].color, arr);
    log(getInfectionStrFull(infect));
    
    // 1
    infect = State.infect_deck[State.infect_deck.length-1];
    State.infect_deck.pop();
    State.infect_drop.push(infect);
    infectTown(infect, State.Towns[infect].color, arr);
    log(getInfectionStrFull(infect));
    
    infect = State.infect_deck[State.infect_deck.length-1];
    State.infect_deck.pop();
    State.infect_drop.push(infect);
    infectTown(infect, State.Towns[infect].color, arr);
    log(getInfectionStrFull(infect));

    infect = State.infect_deck[State.infect_deck.length-1];
    State.infect_deck.pop();
    State.infect_drop.push(infect);
    infectTown(infect, State.Towns[infect].color, arr);
    log(getInfectionStrFull(infect));
    
    str = 'Now the turn is for player';
    str += ' \'';
    str += State.Players[State.cur_player].name;
    str += '\'';
    str += ';';
    
    log(str);
    
    State.started = true;
  }
  
  function Where() {
    var i=0;
    for(i=0; i<State.Players.length; i++) {
      var str = 'Player';
      str += ' \'';
      str += State.Players[i].name;
      str += '\'';
      str += ' is in';
      str += ' \'';
      str += State.Towns[State.Players[i].pos].name;
      str += '\'';
      str += ';';
      log(str);
    }
  }
  
  function Ways(from) {
    var from_id = -1;
    var i=0;
    var from_name;
    if(from == '') {
      // current town of the current player
      from_id = State.Players[State.cur_player].pos;
      from_name = State.Towns[from_id].name;
    } else {  
      for(i=0; i<State.Towns.length; i++) {
        if(State.Towns[i].name == from) {
          from_id = i;
          from_name = State.Towns[from_id].name;
          break;
        }
      }
    }
    
    if(from_id == -1) {
      log('ERROR[Ways]: cannot find the town ' + from);
    }
    
    var str = 'Ways from ';
    str += ' \'';
    str += from_name;
    str += '\'';
    str += ' are:'
    for(i=0; i<State.Towns[from_id].ways.length; i++) {
      if(i != 0) {
        str += ','
      }
      str += ' \'';
      str += State.Towns[State.Towns[from_id].ways[i]].name;
      str += '\'';
    }
    str += ';'
    
    log(str);
  }
  
  function Drive(dest) {
    var pos = State.Players[State.cur_player].pos;
    var pos_dest = getTownIdByName(dest);
    if(pos_dest < 0) {
      log('Incorrect city name.');
    } else if(State.Players[State.cur_player].acts <= 0) {
      log('No actions left.');
    } else if(!isTownInWays(pos_dest, pos)) {
      log('City is unreacheble from the current positon.');
    } else {
      State.Players[State.cur_player].acts--;
      State.Players[State.cur_player].pos = pos_dest;
      
      var str = 'Player';
      str += ' \'';
      str += State.Players[State.cur_player].name;
      str += '\'';
      str += ' is now in';
      str += ' \'';
      str += State.Towns[State.Players[State.cur_player].pos].name;
      str += '\'';
      str += ';';
      log(str);
      
      log('Actions left: ' + State.Players[State.cur_player].acts + ';');
      AutoHeal();
    }
  }
  
  function Fly(dest) {
    var pos_dest = getTownIdByName(dest);
    var pos = State.Players[State.cur_player].pos;

    function match(elem) {
      // searching for card of the corresponding city
      return elem == pos_dest;
    }

    var card_index = State.Players[State.cur_player].hand.findIndex(match);
    
    if(pos_dest < 0) {
      log('Incorrect city name.');
    } else if(pos == pos_dest) {
      log('Choose a city, other that the current one.');
    } else if(State.Players[State.cur_player].acts <= 0) {
      log('No actions left.');
    } else if(card_index < 0) {
      log('Need the card of that city.');
    } else {
      State.Players[State.cur_player].acts--;
      State.Players[State.cur_player].pos = pos_dest;
      State.help_drop.push(pos_dest);
      State.Players[State.cur_player].hand[card_index] = 
      State.Players[State.cur_player].hand[State.Players[State.cur_player].hand.length-1];
      State.Players[State.cur_player].hand.pop();
      
      log('Discarded card \'' + dest + '\'.');
      
      var str = 'Player';
      str += ' \'';
      str += State.Players[State.cur_player].name;
      str += '\'';
      str += ' is now in';
      str += ' \'';
      str += State.Towns[State.Players[State.cur_player].pos].name;
      str += '\'';
      str += ';';
      log(str);
      
      log('Actions left: ' + State.Players[State.cur_player].acts + ';');
      AutoHeal();
    }
  }
  
  function Warp(arg1, eDest, eCost) {
    // @TODO: add Engy
    
    var pos_dest = getTownIdByName(arg1);
    var pos = State.Players[State.cur_player].pos;
    
    function match(elem) {
      // searching for card of this city
      return elem == pos;
    }
    
    var card_index = State.Players[State.cur_player].hand.findIndex(match);
    
    if(pos_dest < 0) {
      log('Incorrect city name.');
    } else if(pos == pos_dest) {
      log('Choose a city, other that the current one.');
    } else if(State.Players[State.cur_player].acts <= 0) {
      log('No actions left.');
    } else if(card_index < 0) {
      log('Need the card of the current city.');
    } else {
      State.Players[State.cur_player].acts--;
      State.Players[State.cur_player].pos = pos_dest;
      State.help_drop.push(pos);
      State.Players[State.cur_player].hand[card_index] = 
      State.Players[State.cur_player].hand[State.Players[State.cur_player].hand.length-1];
      State.Players[State.cur_player].hand.pop();
      
      log('Discarded card \'' + State.Towns[pos].name + '\'.');
      
      var str = 'Player';
      str += ' \'';
      str += State.Players[State.cur_player].name;
      str += '\'';
      str += ' is now in';
      str += ' \'';
      str += State.Towns[State.Players[State.cur_player].pos].name;
      str += '\'';
      str += ';';
      log(str);
      
      log('Actions left: ' + State.Players[State.cur_player].acts + ';');
      AutoHeal();
    }
  }
  
  function Turn() {
    var str = 'Player';
    str += ' \'';
    str += State.Players[State.cur_player].name;
    str += '\'';
    str += ' ended the turn';
    str += ';';
    log(str);
    
    var i=0;
    for(i=0; i<State.Players.length; i++) {
      State.Players[i].acts = State.ACTS_MAX;
    }
    
    if(State.help_deck.length > 0 && State.help_deck[State.help_deck.length-1] == -13) {
      State.help_deck.pop();
      if(!EPIDEMY()) {
        return;
      }
    } else {
      for(i=0; i<State.CARDS_PER_TURN; i++) {
        if(!drawCards(State.cur_player)) {
          return;
        }
        var card_id = State.Players[State.cur_player].hand[State.Players[State.cur_player].hand.length-1];
        log('Current player draws \'' + getCardDispName(card_id) + '\';');
      }
    }
    
    // diseases
    log('Infection time!');
    
    var arr = [];
    for(i=0; i<State.dis_marker; i++) {
      var infect = State.infect_deck[State.infect_deck.length-1];
      State.infect_deck.pop();
      State.infect_drop.push(infect);
      if(!infectTown(infect, State.Towns[infect].color, arr)) {
        return;
      }
      log(getInfectionStrFull(infect));
      
      if(State.infect_deck.length <= 0) {
        log('Refill infection deck');
        State.infect_deck = State.infect_drop;
        State.infect_drop = [];
        shuffleArr(State.infect_deck);
      }
    }
    
    State.cur_player = (State.cur_player+1) % State.Players.length;
    
    if(State.cur_player == State.first_player) {
      State.cur_turn++;
      log('Now it\'s turn number ' + State.cur_turn + ';');
    }
    
    str = 'Player';
    str += ' \'';
    str += State.Players[State.cur_player].name;
    str += '\'';
    str += ' takes the turn';
    str += ';';
    log(str);
  }
  
  function Heal(color) {
    var pos = State.Players[State.cur_player].pos;
    
    if(color == '') {
      color = State.Towns[pos].color;
    }

    if(color != 'B' && color != 'K' && color != 'R' && color != 'Y') {
      log('Wrong color id.');
    } else if(    (color == 'B' && State.Towns[pos].disB <= 0)
        || (color == 'K' && State.Towns[pos].disK <= 0)
        || (color == 'R' && State.Towns[pos].disR <= 0)
        || (color == 'Y' && State.Towns[pos].disY <= 0)) {
      log('Nothing to heal.');
    } else if(State.Players[State.cur_player].acts <= 0) {
      log('No actions left.');
    } else {
      var bMedic = (State.Classes[State.Players[State.cur_player].pclass] == 'Medic');
    
      if(color == 'B') {
        if(bMedic) {
          State.disCntB = State.disCntB - State.Towns[pos].disB;
          State.Towns[pos].disB = 0;
        } else {
          State.Towns[pos].disB--;
          State.disCntB--;
        }
      } else if(color == 'K') {
        if(bMedic) {
          State.disCntK = State.disCntK - State.Towns[pos].disK;
          State.Towns[pos].disK = 0;
        } else {
          State.Towns[pos].disK--;
          State.disCntK--;
        }
      } else if(color == 'R') {
        if(bMedic) {
          State.disCntR = State.disCntR - State.Towns[pos].disR;
          State.Towns[pos].disR = 0;
        } else {
          State.Towns[pos].disR--;
          State.disCntR--;
        }
      } else if(color == 'Y') {
        if(bMedic) {
          State.disCntY = State.disCntY - State.Towns[pos].disY;
          State.Towns[pos].disY = 0;
        } else {
          State.Towns[pos].disY--;
          State.disCntY--;
        }
      }
    
      State.Players[State.cur_player].acts--;
      log(getInfectionStrFull(pos));
      
      log('Actions left: ' + State.Players[State.cur_player].acts + ';');
      KillDiseases();
    }
  }
  
  function Remedy(color, exclude_card1, exclude_card2) {
    if(color != 'B' && color != 'K' && color != 'R' && color != 'Y') {
      log('Wrong color id.');
    } else if((color == 'B' && State.remedyB) ||
              (color == 'K' && State.remedyK) ||
              (color == 'R' && State.remedyR) || 
              (color == 'Y' && State.remedyY)) {
       log('You alredy have this remedy.');
    } else if(!State.Towns[State.Players[State.cur_player].pos].lab) {
      log('Need Lab.');
    } else if(State.Players[State.cur_player].acts <=0) {
      log('No actions left.');
    } else {
      var i=0;
      var used_arr = [];
      var unused_arr = [];
      var e1_id = -1;
      var e2_id = -1;
      if(exclude_card1 != '') {
        e1_id = getTownIdByName(exclude_card1);
        if(e1_id < 0) {
          log('Invalid exclusion - \'' + exclude_card1 + '\'.');
          return;
        }
      }
      if(exclude_card2 != '') {
        e2_id = getTownIdByName(exclude_card2);
        if(e2_id < 0) {
          log('Invalid exclusion - \'' + exclude_card2 + '\'.');
          return;
        }
      }

      var needed_cards = 5;
      if(State.Classes[State.Players[State.cur_player].pclass] == 'Scientist') {
        needed_cards = 4;
      }
      
      // choose proper cards by color, and exclusions
      for(i=0; i<State.Players[State.cur_player].hand.length; i++) {
        var card_id = State.Players[State.cur_player].hand[i];
        
        if(card_id >= 0 && State.Towns[card_id].color == color && card_id != e1_id && card_id != e2_id && used_arr.length < needed_cards) {
          used_arr.push(card_id);
        } else {
          unused_arr.push(card_id);
        }
      }
      
      if(used_arr.length < needed_cards) {
        log('Not enough cards - need ' + needed_cards + ', have ' + used_arr.length + '.');
      } else {
        if(State.Classes[State.Players[State.cur_player].pclass] == 'Scientist') {
          log('Scientist uses four cards to create the remedy');
        }
        
        if(color == 'B') {
          State.remedyB = true;
        } else if(color == 'K') {
          State.remedyK = true;
        } else if(color == 'R') {
          State.remedyR = true;
        }
        log('Remedy created!');
        
        State.Players[State.cur_player].hand = unused_arr;
        log('Used cards: \'' + used_arr.toString() + '\'.');
        log('Other cards: \'' + unused_arr.toString() + '\'.');
        
        if(State.remedyB && State.remedyK && State.remedyR && State.remedyY) {
          Win();
          return;
        }
        KillDiseases();
      }
    }
  }
  
  function Cchange(arg1, arg2) {
    // arg1 = arg2 = ''                     -> giving a card to the defined player
    // arg1 is player id, arg2 = ''         -> give a card to that player
    // arg1 is card name, arg2 = ''         -> (R) give this card to a player
    // arg1 is card name, arg2 is player id -> (R) give this card to this player
  
    var c_id = -1;
    var p_id = -1;
    if(arg1 != '') {
      // can be player name or card name
      var id = getTownIdByName(arg1);
      if(id < 0) {
        id = getPlayerIdByName(arg1);
        if(id < 0) {
          log('Bad cchange.');
          log('Call with player_name/card_name/card_name player_name.');
          return;
        } else {
          p_id = id;
        }
      } else {
        c_id = id;
      }
      
      if(arg2 != '') {
        if(p_id > 0) {
          log('Bad cchange.');
          log('Call with player_name/card_name/card_name player_name.');
          return;
        }
        
        id = getPlayerIdByName(arg2);
        if(id < 0) {
          log('Bad cchange.');
          log('Call with player_name/card_name/card_name player_name.');
          return;
        } else {
          p_id = id;
        }
      }
    }
  
    // spends action
    if(State.Players[State.cur_player].acts <= 0) {
      log('No actions left.');
      return;
    }
  
    if(c_id < 0) {
      // current town by default
      c_id = State.Players[State.cur_player].pos;
    }
  
    var recipient_id = -1;
    var holder_id = -1;
    
    function match(cid) {
      return c_id == cid;
    }
    
    // determine holder
    var cindex = -1;
    var i=0;
    for(i=0; i<State.Players.length; i++) {
      cindex = State.Players[i].hand.findIndex(match);
      if(cindex >= 0) {
        holder_id = i;
        break;
      }
    }
  
    if(holder_id < 0) {
      log('No one holds the card \'' + State.Towns[c_id].name + '\'.');
      return;
    }

    if(State.Players[holder_id].pos != State.Players[State.cur_player].pos) {
      // must be here to exchange
      log('No such card is hold in that position.');
      return;
    }
    
    // determine recipient
    recipient_id = p_id;
    if(recipient_id < 0) {
      for(i=0; i<State.Players.length; i++) {
        if(i != holder_id && State.Players[i].pos == State.Players[State.cur_player].pos) {
          if(recipient_id >= 0) {
            log('There are more than one possible recipients. Choose one of them.');
            return;
          } else {
            recipient_id = i;
          }
        }
      }
    }
    
    if(recipient_id < 0) {
      log('There are no recipients available.');
      return;
    }
    
    if(State.Players[recipient_id].pos != State.Players[State.cur_player].pos) {
      log('Recepient stands in different city.');
      return;
    }
    
    // checking positions and cur player
    if(holder_id != State.cur_player && recipient_id != State.cur_player) {
      log('Current player must participate in exchange.');
      return;
    }
    if(holder_id == recipient_id) {
      log('Cannot exchange with yourself.');
      return;
    }
    
    var researcher_id = getPlayerIdByClassName('Researcher');
    if(c_id != State.Players[State.cur_player].pos) {
      if(holder_id != researcher_id) {
        log('Only Researcher can give card other than a card of the current city.');
        return;
      }
    }
    
    // perform exchange
    State.Players[State.cur_player].acts--;
    State.Players[recipient_id].hand.push(c_id);
    State.Players[holder_id].hand[cindex] =
    State.Players[holder_id].hand[State.Players[holder_id].hand.length-1];
    State.Players[holder_id].hand.pop();
    
    if(c_id != State.Players[State.cur_player].pos) {
      log('Researcher gave the card \'' + State.Towns[c_id].name + '\' to ' + State.Players[recipient_id].name + '\'');
    } else {
      log('Exchange performed successfully. Now card \'' + State.Towns[c_id].name + '\' is in hand of the ' + State.Players[recipient_id].name + '\'');
    }
  }
  
  function KillDiseases() {
    if(!State.defeatedB && State.remedyB && State.disCntB == 0) {
      State.defeatedB = true;
      log('Blue disease finally defeated!');
    }
    if(!State.defeatedK && State.remedyK && State.disCntK == 0) {
      State.defeatedK = true;
      log('Black disease finally defeated!');
    }
    if(!State.defeatedR && State.remedyR && State.disCntR == 0) {
      State.defeatedR = true;
      log('Red disease finally defeated!');
    }
    if(!State.defeatedY && State.remedyY && State.disCntY == 0) {
      State.defeatedY = true;
      log('Yellow disease finally defeated!');
    }
  }
  
  function AutoHeal() {
    var medic_id = getPlayerIdByClassName('Medic');
    if(medic_id > 0) {
      var pos = State.Players[medic_id].pos;
      if(State.remedyB && State.Towns[pos].disB > 0) {
        State.disCntB = State.disCntB - State.Towns[pos].disB;
        State.Towns[pos].disB = 0;
      }
      if(State.remedyK && State.Towns[pos].disK > 0) {
        State.disCntK = State.disCntK - State.Towns[pos].disK;
        State.Towns[pos].disK = 0;
      }
      if(State.remedyR && State.Towns[pos].disR > 0) {
        State.disCntR = State.disCntR - State.Towns[pos].disR;
        State.Towns[pos].disR = 0;
      }
      if(State.remedyY && State.Towns[pos].disY > 0) {
        State.disCntY = State.disCntY - State.Towns[pos].disY;
        State.Towns[pos].disY = 0;
      }
      KillDiseases();
    }
  }
  
  function Info() {
    log('Detailed game info:');
    var i=0;
    for(i=0; i<State.Towns.length; i++) {
      if(State.Towns[i].disB > 0 || State.Towns[i].disK > 0 || State.Towns[i].disR > 0) {
        log(getInfectionStrFull(i));
      }
    }
  }
  
  function EPIDEMY() {
    log('EPIDEMY! (No ' + State.epidemy_id + ')');
  
    State.epidemy_id++;
    State.dis_marker = State.dis_markers[State.epidemy_id];
    
    var infect = State.infect_deck[0];
    State.infect_drop.push(infect);
    State.infect_deck.shift();
    
    log('New city \'' + State.Towns[infect].name + '\' is infected.');
    
    var arr = [];
    var i=0;
    for(i=0; i<3; i++) {
      if(!infectTown(infect, State.Towns[infect].color, arr)) {
        return false;
      }
      if(arr.length > 0) {
        // outbreak in this town
        break;
      }
    }
    
    shuffleArr(State.infect_drop);
    for(i=0; i<State.infect_drop.length; i++) {
      State.infect_deck.push(State.infect_drop[i]);
    }
    State.infect_drop = [];
    return true;
  }
  
  function Lose(reason) {
    log('You lose because of \'' + reason + '\'');
    log('Type \'/start\' to start new game');
    State.started = false;
  }
  
  function Win() {
    log('Congratulations! You\'ve created all of four remedies for each of those deadly disease. Now the World can live in calmness and health.');
    State.started = false;
  }
  
  function Help() {
    log('Available commands:');
    log('/help - display available commands (this message);');
    log('/start - starts new game;');
    log('/ways - available cities for the current player to drive to;');
    log('/drive \'CITY_NAME\' - current player moves to the city next to that player\'s pos;');
    log('/heal <\'COLOR_LETTER\'> - current player heals disease of color, defined by COLOR_LETTER (B for Blue, K - for Black, R - for Red, Y - for yellow), without COLOR_LETTER - disease of the city\'s color;');
    log('/turn - end of turn, next player takes turn;');
    log('/fly \'CITY_NAME\' - current player moves to the CITY_NAME, using the card of that city;');
    log('/warp \'CITY_NAME\' - current player moves to any city, using the card of the city that player stands in right now;');
    log('/remedy \'COLOR_LETTER\' \'EXCLUDE_CARD1\' \'EXCLUDE_CARD2\' - current player invents the remedy in a city with the lab from disease of color indicated by COLOR_LETTER, using cards, excluding EXCLUDE_CARD1 and EXCLUDE_CARD2;');
    log('/cchange - current player takes or gives the card of the city that player stands in to another player, that stands in that city;');
    
    log('/misc_clr - clears the screen.');
  }
  
  // Scientist +
  // Quarantine Specialist +
  // Medic +
  // Researcher +
  
  // v-prj0.herokuapp.com
</script>
<div class="row">
    <textarea class="form-control" rows="40" id="allOutput" readonly style="padding-left: -60px;padding-right: -60px;width: 100%;min-width: 100%;max-width: 100%; height: 400px;min-height: 400px;max-height: 400px;">Welcome to Digital Pandemic v0.10 beta by Varyier (02.02.2018 4:25 AM). Type '/help' and click sumbit to see available commands.</textarea>
</div>
<div class="row" onkeydown="if(event.keyCode==13) { mymain(); }">
    <div class="input-append">
        <input class="span2" id="mainInput" type="text" style="padding-left: -60px;padding-right: -60px;width: 90%;min-width: 90%;max-width: 90%;">
        <button class="btn" type="button" onclick="mymain()">Sumbit</button>
        <p id="demo"></p>
    </div>
</div>
<div class="row" hidden>
    <textarea class="form-control" rows="2" id="ST" readonly style="padding-left: -60px;padding-right: -60px;width: 100%;min-width: 100%;max-width: 100%; height: 400px;min-height: 400px;max-height: 400px;"></textarea>
</div>